using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Threading;
using Twilio;
using Twilio.Rest.Api.V2010.Account;
using Twilio.Types;

namespace SystemProgrammingExam
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private CancellationTokenSource tokenSource;
        public MainWindow()
        {
            InitializeComponent();

        }

        private async void SendSMS(object sender, RoutedEventArgs e)
        {
            tokenSource = new CancellationTokenSource();
            //ButtonPressDelay();
            //var timer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(30) };
            //timer.Start();
            //bool result = Regex.Match(phoneTextBox.Text, @"\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})").Success;
            //MessageBox.Show(result.ToString());
            string phoneNumber = $"+7{phoneTextBox.Text}";
            if (Regex.Match(phoneTextBox.Text, @"\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})").Success)
            {
                await Task.Delay(3000);
                await Task.Run(() =>
                {
                    string accountSid = Environment.GetEnvironmentVariable("AC15a9364b89062d729d06c9977c0d1e6c");
                    string authToken = Environment.GetEnvironmentVariable("7d1c9721d9cc263875d3e00a70f70d8c");


                    TwilioClient.Init(accountSid, authToken);

                    var message = MessageResource.Create(
                    body: smsTextBox.Text,
                    from: new Twilio.Types.PhoneNumber("+12058947575"),
                    to: new Twilio.Types.PhoneNumber(phoneTextBox.Text)
                );

                }, tokenSource.Token);
                await Task.Delay(30000);
            }
            else
            {
                MessageBox.Show("Неправильно введен номер телефона");
            }

            MessageBox.Show("SMS отправлено");

        }

        public async void ButtonPressDelay()
        {
            await Task.Delay(30000);
        }


        /*
         * 1) Какие потоки есть в вашем приложении? Является ли ваше приложение многопоточным?
         * В моем приложении есть Task.Run, который выполняет отпраку смс на номер телефона. В моем приложении
         * используется только один Task.Run, приложение использующее TPL можно считать многопоточным, но так как
         * у меня всего один поток, думаю, оно не является многопоточным
         * 2) Какие типы операций IO/CPU bound присутствуют в вашем приложении? 
         * Объясните, как вы поняли к какому типу относятся эти операции?
         * CPU bound - это операции, которые выполняют со стороны моего компьютера, какие-то тяжелые операции.
         * IO bound - операции, которые выполняются независимо от моего компьютера, например, обращение к бд.
         * В моем приложении присутсвует работа с Twilio, IO bound операция, никаких тяжелых операций, которые
         * выполняются на стороне моего компьютера нет.
         * 3) Является ли использование максимально большого количества потоков в вашем приложении способом 
         * улучшить его производительность? Почему?
         * Это будет эффективно, только если они будут выполняться асинхронно, параллельно. Из-за большого
         * количества потоков оно возможно будет работать быстрее, но не факт, что правильно, так как потоки
         * не будут выполняться последовательно
         * 4) Task является потоком?
         * Нет. Task использует пул потоков и распределяет задачи доступным процессорам, также предоставляет
         * разбиение работы на части, управление потоками, управлением их состояния
         * 5) Зачем в приложении отслеживание "закликивания" отправки сообщения?
         * Чтобы не было большой нагрузки на процессор и на Twilio, так как с каждым нажатием создается Task,
         * будет больше тасков - будет дольше работать приложение
         * 6) В случае изменения поведения вашего приложения в сторону массовой отправки на множество
         * номеров (до 100) одного и того же сообщения, что нужно будет изменить, 
         * какие типы использовать и почему?
         * Наверно, использовать PLINQ, чтобы параллельно отправлять на несколько номеров смс, чтобы
         * не загружало приложение и не мешало работе/выполнению приложения
         * 7) Будет ли произведена отправка сообщения, если после нажатия кнопки в конце метода обработки 
         * нажатия на кнопку будет произведено отключение приложения (выгрузка процесса)? Если нет, 
         * то можно ли это как-то исправить? Если да, то как именно это произойдёт и почему?
         * Сообщение не отправится в том случае, если приложение полностью прекратит работу(если окно закроется).
         * А если окно не закроется, то Task выполнится до конца, так как он продолжает выполнение, даже если 
         * весь метод Main выполнен. Думаю, способом решения такой задачи проверка Task, выполнен он или нет,
         * и потом уже завершать приложение, останавливать его работу.
         * 8) Используете ли вы Dispatcher для обращения к UI элементам из другого потока? Почему?
         * Нет, не использую, у меня нет обращения к ним, у меня нет другого потока, чтобы обращаться к нему
         * 9) Где в вашем приложении возникает конкурентность? Как вы её решили и почему?
         * Думаю, конкурентность возникнет на моменте Task.Delay и отправке сообщения, я добавил async/await
         * в качестве решения такой проблемы
         * 10) Будет ли считаться оптимизацией загрузка и выгрузка в домен вашего процесса библиотеки
         * отправки смс сообщений в вашем случае? Почему?
         * Нет, потому что это будет запонять память, так как не будет немедленно выгрузки памяти, следовательно
         * будет занята память, что не очень хорошо
         * 11) Если ваше приложение разбить на 2 отдельных программы (отдельно UI и отдельно отправка), 
         * можно ли будет сделать оба этих приложения однопоточными?
         * Да, можно будет
         * 12. Какая разница между ассинхронностью и многопоточностью? Что из этого и почему вы используете 
         * в своём приложении?
         * Асинхронность выпоняется как бы параллельно, то есть распределяет обязанности на рабочих и
         * заставляет их выполнять поставленную задачу. Многопоточность же выполняет несколько задач, но
         * не параллельно, то есть выполнила часть одной задачи, перешла к другой, выполнила ее, вернулась к
         * первой. А асинхронность выполняет две задачи одновременно. Я использую асинхронность, это эффективнее
         * для работы приложения.
         * 
         */
    }
}
